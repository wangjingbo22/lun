#include "lqr.h"
#include <math.h>

// 12个状态增益，每个有4个多项式系数 (a*L^3 + b*L^2 + c*L + d)
// 顺序: 
// 0-5: 轮子电机 [theta, d_theta, x, d_x, phi, d_phi]
// 6-11: 髋关节 [theta, d_theta, x, d_x, phi, d_phi]
// 注意：以下数据是示例占位符，请运行上面的 MATLAB 代码获取真实数值填入！
// const float LQR_DUAL_COEFFS[12][4] = {
//     { 1538.0577,  -629.9980,   101.9511,    11.3646}, // Wheel_Theta
//     {  117.3355,   -48.0502,    10.8294,     1.3606}, // Wheel_Gyro
//     {  183.4809,   -74.6997,    11.3302,     1.8847}, // Wheel_X
//     { -574.3611,   201.7199,   -25.7087,     4.8407}, // Wheel_V
//     {  529.0393,  -282.0176,    63.4991,    -7.1700}, // Wheel_Phi
//     {   90.7113,   -41.1526,     7.8520,    -0.7892}, // Wheel_PhiV
//     {  444.7340,  -308.8569,    85.1101,   -11.1437}, // Hip_Theta  
//     {   69.5359,   -40.1033,     9.9134,    -1.3268}, // Hip_Gyro  
//     {  136.5974,   -72.8166,    16.3954,    -1.8513}, // Hip_X  
//     { 1033.4102,  -397.5074,    58.8126,    -4.1363}, // Hip_V  
//     { -710.6183,   289.3109,   -43.8816,    -7.2993}, // Hip_Phi  
//     { -112.3489,    43.4218,    -6.1703,    -0.4974}, // Hip_PhiV  
// };

// const float LQR_DUAL_COEFFS[12][4] = {
//     { 1159.4382,  -514.6485,    90.6505,    11.7186}, // Wheel_Theta
//     {   90.9018,   -39.9922,    10.0394,     1.3854}, // Wheel_Gyro
//     {  140.1028,   -61.4781,    10.0341,     1.9253}, // Wheel_X
//     { -289.7696,   115.3617,   -17.2908,     4.5788}, // Wheel_V
//     {  493.8692,  -271.2297,    62.4332,    -7.1362}, // Wheel_Phi
//     {   69.5677,   -34.7212,     7.2232,    -0.7696}, // Wheel_PhiV
//     {  540.6142,  -337.8689,    87.9278,   -11.2309}, // Hip_Theta
//     {   68.7532,   -39.8524,     9.8872,    -1.3259}, // Hip_Gyro
//     {  127.5165,   -70.0312,    16.1202,    -1.8426}, // Hip_X
//     {  642.7749,  -278.8478,    47.2309,    -3.7753}, // Hip_V
//     { -542.6159,   238.1038,   -38.8620,    -7.4566}, // Hip_Phi
//     {  -76.6661,    32.5675,    -5.1090,    -0.5306}, // Hip_PhiV
// };

const float LQR_DUAL_COEFFS[12][4] = {
    {  274.4907,  -118.5892,    20.7296,     3.3950}, // Wheel_Theta
    {   13.4576,    -5.4909,     1.8020,     0.3507}, // Wheel_Gyro
    {   26.3051,   -10.9025,     1.6266,     0.5979}, // Wheel_X
    { -111.5234,    45.5901,    -6.9854,     1.3137}, // Wheel_V
    {  411.4001,  -202.5906,    39.7160,    -3.5717}, // Wheel_Phi
    {   46.9164,   -22.4374,     4.2750,    -0.3833}, // Wheel_PhiV
    {  143.3141,   -74.1460,    15.4023,    -1.4807}, // Hip_Theta
    {   14.6743,    -7.4735,     1.5458,    -0.1567}, // Hip_Gyro
    {   30.2407,   -14.8918,     2.9194,    -0.2625}, // Hip_X
    {  103.8981,   -44.1956,     7.1151,    -0.4983}, // Hip_V
    { -169.5122,    70.2568,   -10.4817,    -3.8527}, // Hip_Phi
    {  -19.4393,     7.9902,    -1.1817,    -0.3532}, // Hip_PhiV
};

LQR_Dual_K Get_LQR_Dual_K(float L) {
    LQR_Dual_K k;
    
    // 限制输入范围，防止多项式拟合在范围外发散
    if(L < 0.04f) L = 0.04f; 
    if(L > 0.14f) L = 0.14f;
    
    float t1 = L;
    float t2 = L * L;
    float t3 = L * L * L;
    
    // 利用指针强制转换，把结构体当成 float 数组遍历
    // 结构体内存布局必须与 LQR_DUAL_COEFFS 行顺序一致
    float *p = (float*)&k;
    
    for(int i = 0; i < 12; i++) {
        p[i] = LQR_DUAL_COEFFS[i][0] * t3 + 
               LQR_DUAL_COEFFS[i][1] * t2 + 
               LQR_DUAL_COEFFS[i][2] * t1 + 
               LQR_DUAL_COEFFS[i][3];
    }
    
    return k;
}